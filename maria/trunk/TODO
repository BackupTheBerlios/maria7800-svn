- Do EmuTraceListener (could probably just dump stuff
  to System.Console)
- At some point we should look at all those Trace and Debug
  outputs and should decide which should be Trace and which
  should be Debug and which should go directly to
  stdout/stderr...
- maria.exe will probably just a small stub that invokes
  the real main program inside Maria.Core. The main purpose
  for Maria.Core is anyway to have things in a class library,
  which is needed for nunit testing...
  => should probably do that soonish...maria.exe will then
  just create/run MariaApp, which does the real work.
  Oh well. The whole shebang is just so difficult to modify,
  since everything is friggingly hooked together...
- Give Machine class a try ?
  - construction method (Maria.New) not yet complete...
- The RomProperties class might be a neat candidate too.
  Here we should add a few unixish things:
  - Can we ensure we can read under linux/win32 both
    Unix/Windows/Whatever style files ? (Well, actually
    this is not really a problem atm, I'm not gonna support
    Windows myself anyway...)
  - We keep a system wide and a user RomProperties.csv file.
  - The system-wide file is in the pkglibdir, so we can find
    it by getting maria.exe's directory.
  - The user file is in the user's home directory, don't know
    where exactly, though. perhaps in a ~/.maria directory ?
  - At startup we first read in the system-wide RomProperties.
    When we have it, we read the user RomProperties file. Any
    entries in the user-file that have the same MD5 sum as
    entries in the system-wide file will override those in
    the system-wide file. Pretty simple, isn't it ?
    => actually we don't do it at startup, lazy construction
       might make more sense in this particular case.
  - It might be a good idea not to crash the application
    when reading romproperties goes wrong. config files
    disappear all the time, so if they aren't there, we
    should try to run without them...
- Other packages licences need to be deployed/installed too:
  - Tao.Sdl.dll
  - For windows, if we distirbute dll binaries, we must also
    distribute the SDL-license.txt (or however it is called again.)
  => Blah...we keep a doc dir around or somesuch which we'll install
    to...well...wherever docs go...
- Currently we simply use Tao assemblies built for 1.1
  is this a good thing (what if the target framework is 2.0 ?)
- Possibly we can work on the Cart classes.
  - I think I'll port the remaining carts and then
    worry about refactoring them.
- Build process:
  - At some point we should perhaps keep referenced assemblies
    as dependencies of the assembly that should be built.
- Learn how to tag stuff, and tag the ORIGINAL emu7800 source code
  in the repository with 0.71 or somesuch.
- Raise warning level when compiling ?
- At some point search for \n sequences in source code and
  replace them by Environment.NewLine. Or so. Oh well.
---
Stuff to clean up:
- The whole Cart base/concrete class business looks a bit odd to me
- Duplicated code (offset calculation) in MD5.cs and GameSettings.cs
- Does GameSettings really need that many getters/setters ?
  (Nah. Probably it could happily be an immutable)
- Odd that AddressSpace owns a Machine reference, because it never uses it...
- The CommandLine class looks odd too:
  - Why isn't Parameter a class ? Would make things simpler.
  - Why isn't CommandLine.Parms an IList instead of an array ?
    CommandLine class itself could have a strongly typed string indexer...
